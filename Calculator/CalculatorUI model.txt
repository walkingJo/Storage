--------------------------------------------------

+-----------------------------+
|                             |
|                             |
|                             |
+-----+-----+-----+-----+-----+
|     |     |     |     |     |
|     |     |     |     |     |
|     |     |     |     |     |
|     |     |     |     |     |
|     |     |     |     |     |
|     |     |     |     |     |
+-----+-----+-----+-----+-----+

{
    { "x^2", "pi ", " e ", "Cls", "bsp" },
    { "x^y", " ( ", " ) ", " ! ", " / " },
    { " ? ", " 7 ", " 8 ", " 9 ", " * " },
    { " ? ", " 4 ", " 5 ", " 6 ", " - " },
    { "log", " 1 ", " 2 ", " 3 ", " + " },
    { "ln ", "+/-", " 0 ", " . ", " = " }
}

--------------------------------------------------

+-----------------------------+
|                             |
| ..10^2+21)/11               |
|                       = 11  |
+-----+-----+-----+-----+-----+
| x^2 | pi  |  e  | Cls | bsp |
| x^y |  (  |  )  |  !  |  /  |
|  ?  |  7  |  8  |  9  |  *  |
|  ?  |  4  |  5  |  6  |  -  |
| log |  1  |  2  |  3  |  +  |
| ln  | +/- |  0  |  .  |  =  |
+-----+-----+-----+-----+-----+

1~5 | 7~11 | 13~17 | 19~23 | 25~29

--------------------------------------------------

//타입들
enum class ElementType {
    num, constNum, prefixFunc, infixFunc, postfixFunc
};

--------------------------------------------------

addLSBracket
addRSBracket
addLMBracket
addRMBracket
addLLBracket
addRLBracket

/*!*/    각 연산자 별 앞에 있어야 하는 것들
/*!*/            숫자     전위      중위      후위
/*!*/    숫자     X        X        O        O
/*!*/    전위     O        O        X        X
/*!*/    중위     O        O        X        X
/*!*/    후위     X        X        O        O

마지막 요소는 숫자나, 후위 함수여야 함

--------------------------------------------------

기본적으로 모든 연산자는 공통된 스택을 사용할 것.

스택은 아래처럼 총 두 개로 구성된다.
    1. 인자 스택
    2. 함수 스택

괄호 안부터 인자와 함수들을 우선순위를 고려하여 큐에 넣는다.
    >> 우선순위가 높은 것을 우선적으로 앞에 넣는다.

*그리고 연산이 끝난 결과는 다시 큐에 넣는다.

그리고 이걸 계속 반복.

함수가 0개가 되면 큐의 마지막 요소를 반환

---------------
2 + 3 * 31
-----
2 3 31
+ *
-----
'*'
<< 3 * 31
-----
2 93
+
-----
'+'
<< 2 + 93
-----
95
--------------------
2 * (3 + 11) / 4
-----
3 11 2 4
+ * /
-----
'+'
<< 14
-----
14 2 4
* /
-----
'*'
<< 28
-----
28 4
/
-----
'/'
<< 7
--------------------

문제상황 : 순서가 중요한 두 연산자는 어떻게 되는가
    이거 큐건 스택이건 어떻게 해도 중복으로 문제생긴다
    컴파일러에서 사용하는 구문 트리를 사용해 만들자 
        https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC
        https://ko.wikipedia.org/wiki/추상_구문_트리

제안)
    굳이 트리 구조로 해서 복잡하게 가지 말고
    리스트 형태로 하고 쌓여있는 L_Braket의 개수만큼 랭크를 부여하는건?
    계산이 완료되면 한칸씩 아래로 내려오는 그런거
ex) 2 * (3 + 11) / 4 :
    /
    *
        2
        +
            3
            11
        4
전부 다 써놓고 보니까 좀 난잡해 보이기도 하고

/   *   2
        +   3
            11
    4
이것도 뭐 그리 깔끔하진 않네
--------------------

기본적인 전략으로, 구문을 트리 형식으로 합치는 것은 calculator 안에서 하는 걸로

구문 계산 과정은 DFS를 활용하자
--------------------

1. 식들을 트리 형태로 분리
2. DFS 방식으로 함수들을 모두 계산
    스택 활용
3. 계산식 구현 필요
    특히 (정수&정수)는 정수로, 그 외는 실수로 계산 필요
--------------------

[ 2 * (3 + 11) / 4 ]

괄호가 없는 경우의 수식 분해 :
    영어 연산자가 있으면 괄호는 필연
    1. '*', '/'를 차례로 계산
    2. '+', '-'를 차례로 계산

괄호의 기능을 정의 비스무레하게 접근해 보자.
    활호는 애초에 연산의 우선순위를 명시하는 것 외에는 기능이 없다
    따라서 마찬가지로 연산 우선순위에 대해 함수를 작성하고, 이를 조정하는 방식으로 괄호를 인식하면 되지 않을까

괄호와 ','가 있는 경우의 수식 분해
    ...
--------------------------------------------------

정답은 괄호를 고려한 함수와 괄호를 고려하지 않은 평문을 계산하는 함수를 분리해 설계하는 것이다.
    첫째 함수는 괄호를 찾아내 모든 괄호를 분해하고,
    둘때 함수는 괄호가 없어진 간단한 식을 편히 계산한다
--------------------------------------------------