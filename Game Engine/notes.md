# 2024-04-27

드디어 오늘, 게임 엔진 프로젝트를 본격적으로 시작한다!

~~↑↑ 이거 왜 써놓고 작업 안했는지 나는 아직도 모른다.~~

# 2024-04-30

### 게임 엔진의 필요 기능들
게임엔진의 전체적인 틀을 짜기 위해 어떤 기능들일 필요한지 나열해보았다.
- 객체 시스템
   - 움직임 및 회전
   - 애니메이션
   - AI 상태 변화 ← 이거는 객체&시스템 중 어디다 전가할까
- 게임 시스템(`GameEngine`, `GameManager`)
   - 충돌 판정 ← `GameManager`에게의 정보 전달을 어떻게 할 것인지?
   - 객체 지정
   - 점수 등 계산
- 전투 시스템
   - 무기 장착 & 교체
   - 공격
      - 투사체 공격
      - 근접 공격
   - 특수 판정
      - 그로기
      - 잡기
      - 무적
- 카메라 조작

---

### 핵심 클래스 연결도
이 프로젝트의 구조적인 축은 `Game`, `GameEngine`, `GameManager`이고, 기능적인 축은 `RenderEngine`, `PhysicsEngine`, `Object`이다.
위 클래스들은 아래와 같이 연결된다.
```
[구조 연결도]
                         +------+
           +------------→| Game |
           |             +------+
    +------+------+
    | GameManager | ---→ 게임엔진의 오브젝트 목록 참조 가능
    +------+------+
           |                               
           |          +------------+
           +---------→| GameEngine |
                      +------------+

[기능 연결도]
    +--------------+           +---------------+
    | RenderEngine |←----+----→| PhysicsEngine |
    +--------------+     |     +---------------+
                         |
                   +-----+------+
                   | GameEngine |
                   +------------+
                         ↑
                         |
                    +----+---+
                    | Object |
                    +--------+
```
각각의 기능은 아래와 같다.
1. `Game`
   - 아래 클래스들에 접속해 동작시키는 역할
   - 초기화 외에 특수하게 조작하는 기능은 없다
2. `GameEngine`
   - 게임의 연산들을 실행시키는 역할
   - 이 클래스는 별도의 조작이 전혀 없을 예정이다
3. `GameManager`
   - 게임을 실질적으로 진행시키는 역할
   - 이 클래스는 무조건 상속을 통해 플레이어가 재정의해야 한다

# 2024-05-01

아래 클래스들의 연결을 수행했다.
각각의 관계에 근거하여 생성자 및 `init()`함수, 소멸자를 정의했으며, `GameEngine`과 `GameManager`의 경우에는 특별히 `setManager()`과 `setEngine()`를 만들어 서로를 필드 값으로 지정할 수 있도록 했다.
```
[조작 연결도]
    +------+     +------------+           +---------------+
    | Game +----→| GameEngine |←----+----→| GraphicEngine |
    +-----++     +------------+     |     +---------------+
          |         ↑               |     +---------------+
          ↓         |               +----→| PhysicsEngine |
        +-----------+-+                   +---------------+
        | GameManager |
        +-------------+
```

---

### 추가할 것 :
- `GameEngine`클래스에 `GetInput()`함수 추가 및 **입력 전달 방법** 고민
- `Vector3`의 `rotate(axis, radian)`함수를 쿼터니언을 통해 구현

### `Model`사이의 연결.

사람처럼 관절이 존재하는 모델을 만들기 위해서는 여러 모델을 상하관계를 두어 연결해야 한다.
1. 모델의 정보는 ***최소한으로 수정***하는 것을 기본으로 한다.
   - 평행이동에 대한 정보는 모델이 아닌 `Object`의 `location`에 저장한다.
   - 회전에 대한 정보는 `Object`와 `Model`모두에 저장한다.
2. 부모 `Model`과의 연결
   - 고려사항 :
     - 인간의 관절처럼 작용해야 한다.
     - 부모 모델이 회전하면 자식 모델 또한 회전해야 한다.
     - 각각의 자식 모델은 방향과 중심점을 가져야 한다.
   - 제안(이지만 사실상 이 방법으로 갈 것 같다.) :
     - `centor`가 갖던 본래의 의미를 버리고, `(0,0,0)`을 중심점으로 갖도록 한다.
     - 모델의 좌표들은 기본적으로 움직이지 않는다. 렌더링 때 사용하는 좌표는 객체를 새로 생성해 사용한다.~~(<<실행 시간이 조금 걱정되는데 일단 적용시키고 보자)~~
     - `centor`와 `direction`을 선언해 **최상위 모델에 대한** 위치, 방향을 저장한다.
       - 상위 모델을 회전시킬 때 수정되는 것은 이 정보들 뿐이다.
       - 최상위 모델의 `centor`는 `(0,0,0)`로 고정된다.

3. `Object`가 움직일 때, 부속된 `Model`도 움직이게 만들기 | **출력 직전에 계산해서 만들기**
   - 후자의 경우 `Model`의 `Center`필드를 제거하는 것이 가능하다.

4. 오브젝트 회전의 중심점 확장
   - 부모 오브젝트의 회전과 자유로운 회전을 위해 회전 중심점을 가변적으로 설정할 수 있어야 한다.
   - 이때, 중심 이외의 회전점을 지정할 수 있도록 함수를 정의해야 한다.

# 2024-05-03

### 입력과 관련된 모든 처리는 `InputProcessor` 클래스를 만들어 활용하도록 한다.
기본적으로는 마우스와 키보드 입력만을 저장한다.
기존 버전의 차이점은 다음과 같다.
- 화면(카메라) 회전에 대한 코드는 manager로 이양한다.
- ESC 등의 입력으로 프로세스를 종료할 때, 즉각적으로 종료되지 않고 **딜레이**가 생긴다.
- 마우스의 위치 정보는 `MouseCoord`라는 클래스를 새로 만들어 전달하는걸로

또한 현재의 마우스의 움직임 인식은 클릭 도중에만 적용된다.
이는 마우스를 중앙으로 옮길 수 없기 때문에 쓰는 일종의 꼼수이다.
따라서 마우스를 중앙으로 옮길 수 있다면 이 문제는 해결되지만, **마우스를 중앙으로 옮기는 코드를 어디에 삽입해야 하는지**도 문제다.

```
[InputProcessor 선언에서의 오류]

error C2027: 정의되지 않은 형식 'InputProcessor'을(를) 사용했습니다.

InputProcessor 의 타입으로 선언하는 모든 변수에서 C2027 의 오류가 발생함.
    GameEngine 의 부속 클래스인 InputProcessor 가 그 아래에 있어서 생긴 문제로 추정되며,
    마치 함수 정의를 아래에 둘 때, 프로토타입을 선언하는 것과 같은 이치라고 판단됨.
```

---

### `Update`의 순서?
- `pEngine`, `gEngine`, `manager`, `object`의 업데이트 순서를 어떻게 정해야 하는가?
- 일단 `gEngine`가 가장 마지막에 실행되는 것은 고정이다.
- `manager`를 계산하기 위해서는 충돌 관련 정보가 필요하므로 `pEngine`가 선행되어야 한다.
- `object`의 업데이트는 적 인식 등이 포함되므로 `pEngine`가 선행되어야 한다.
- 그리고 자잘한 것만 하면서도 다른 영향을 받는 것은 좋지 않으니 `object`→`manager`로 한다.

따라서 최종적인 순서는 `pEngine`→`object`→`manager`→`gEngine` 이다.

---

### `GameManager`의 활용!
- 게임 엔진을 조작해 게임을 진행하는 코드를 업데이트에 넣도록 한다.
- 마치 **유티니의 `Scene`과 같은** 활용법도 가능할듯.
  - GameManager를 다수 생성해서 특정 상황에서 교체해 사용

---

### `RenderEngine` 구현

`update()`는 다음의 순서로 구현된다.
```cpp
void update(Object** objects, int objectCount) {
    clear(0, 0, 0);
    //drawAllObject();
    for (int i = 0; i < objectCount; ++i)
        drawObject(objects[i]);
    renderPresent();
}
```
본래대로라면 `GameEngine*`를 받아서 진행해야 하지만, `C2027`오류 때문에 위와 같이 진행하게 됐다.

---

### `Model::rotate()` 구현

`rotate()`는 아래와 같이 구현했다. 변수의 값을 바꾸는 동시에 반환값이 존재한다.
```cpp
Vector3 rotate(const Vector3& axis, float radian) {
    //https://jebae.github.io/quaternion-rotation
    Vector3 qv = sin(radian / 2.0f) * axis;
    float   qw = cos(radian / 2.0f);
    *this += 2.0f * Vector3::Cross(qv, Vector3::Cross(qv, *this) + qw * *this);

    return *this;
}
```

---

### 현재 남은 작업들

- `Model`의 부모-자식간 연결의 정하기
- `Object`세부 사항 구현
- `GameManager`의 테스트 케이스 구성
  - 카메라 1개 | 오브젝트 3개 | 광원 1개
- `GraphicEngine`의 렌더링 기능 구현
  - 기저변환, 사영변환
  - 깊이 버퍼 활용
  - 광원 효과 구현
- `PhysicsEngine`의 충돌 판정 및 중력 등 구성
  - 충돌 정보 전달 방식 정하기

# 2024-05-04

### 오브젝트의 상태 저장 방식
- 주 상태와 보조 상태를 구분지어 저장하는 기능이 필요하다.
  - `enum class`의 각각의 요소가 하위 개체를 갖는 것이 가능한가?
  - 보조 상태가 얼마 되지 않는다면 `BATTLE_FIGHT`, `BATTLE_GROGGY`처럼 하나하나 다 만드는 것도 상관은 없을 것 같다.
  - 아니면 상태 변수를 2개 만들어 활용하는 것도 고려해볼 만 하다.

---

### manager의 역할
FPS같은 경우는 대부분 객체의 프로세스를 따른다.
그렇다면 `manager`가 하는 일은 무엇인가?
- 카메라 조작
- 배그 : 점수 저장 및 자기장 관리(이동, 피해 등)
- 카드게임류 : GM의 그것
- `Dark Souls` : 진행도 저장 및 NPC 이벤트 관리
`manager`를 단순한 오브젝트에서 격상시킨 것은 의미 있는 일이다.
