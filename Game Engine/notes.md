## 2024-04-27

드디어 오늘, 게임 엔진 프로젝트를 본격적으로 시작한다!

~~↑↑ 이거 왜 써놓고 작업 안했는지 나는 아직도 모른다.~~

## 2024-04-30

### 게임 엔진의 필요 기능들
게임엔진의 전체적인 틀을 짜기 위해 어떤 기능들일 필요한지 나열해보았다.
- 객체 시스템
   - 움직임 및 회전
   - 애니메이션
   - AI 상태 변화 ← 이거는 객체&시스템 중 어디다 전가할까
- 게임 시스템(`GameEngine`, `GameManager`)
   - 충돌 판정 ← `GameManager`에게의 정보 전달을 어떻게 할 것인지?
   - 객체 지정
   - 점수 등 계산
- 전투 시스템
   - 무기 장착 & 교체
   - 공격
      - 투사체 공격
      - 근접 공격
   - 특수 판정
      - 그로기
      - 잡기
      - 무적
- 카메라 조작

---

### 핵심 클래스 연결도
이 프로젝트의 구조적인 축은 `Game`, `GameEngine`, `GameManager`이고, 기능적인 축은 `RenderEngine`, `PhysicsEngine`, `Object`이다.
위 클래스들은 아래와 같이 연결된다.
```
[구조 연결도]
                         +------+
           +------------→| Game |
           |             +------+
    +------+------+
    | GameManager | ---→ 게임엔진의 오브젝트 목록 참조 가능
    +-------------+
           ↑                               
           |          +------------+
           +---------→| GameEngine |
                      +------------+

[기능 연결도]
    +--------------+           +---------------+
    | RenderEngine |←----+----→| PhysicsEngine |
    +--------------+     |     +---------------+
                         |
                   +-----+------+
                   | GameEngine |
                   +------------+
                         ↑
                         |
                    +----+---+
                    | Object |
                    +--------+
```
각각의 기능은 아래와 같다.
1. `Game`
   - 아래 클래스들에 접속해 동작시키는 역할
   - 초기화 외에 특수하게 조작하는 기능은 없다
2. `GameEngine`
   - 게임의 연산들을 실행시키는 역할
   - 이 클래스는 별도의 조작이 전혀 없을 예정이다
3. `GameManager`
   - 게임을 실질적으로 진행시키는 역할
   - 이 클래스는 무조건 상속을 통해 플레이어가 재정의해야 한다

## 2024-05-01

아래 클래스들의 연결을 수행했다.
각각의 관계에 근거하여 생성자 및 `init()`함수, 소멸자를 정의했으며, `GameEngine`과 `GameManager`의 경우에는 특별히 `setManager()`과 `setEngine()`를 만들어 서로를 필드 값으로 지정할 수 있도록 했다.
```
[조작 연결도]
    +------+     +------------+           +---------------+
    | Game +----→| GameEngine |←----+----→| GraphicEngine |
    +-----++     +------------+     |     +---------------+
          |         ↑               |     +---------------+
          ↓         |               +----→| PhysicsEngine |
        +-----------+-+                   +---------------+
        | GameManager |
        +-------------+
```

---

### 추가할 것 :
- `GameEngine`클래스에 `GetInput()`함수 추가 및 **입력 전달 방법** 고민
- `Vector3`의 `rotate(axis, radian)`함수를 쿼터니언을 통해 구현

### `Model`사이의 연결.

사람처럼 관절이 존재하는 모델을 만들기 위해서는 여러 모델을 상하관계를 두어 연결해야 한다.
1. 모델의 정보는 ***최소한으로 수정***하는 것을 기본으로 한다.
   - 평행이동에 대한 정보는 모델이 아닌 `Object`의 `location`에 저장한다.
   - 회전에 대한 정보는 `Object`와 `Model`모두에 저장한다.
2. 부모 `Model`과의 연결
   - 고려사항 :
     - 인간의 관절처럼 작용해야 한다.
     - 부모 모델이 회전하면 자식 모델 또한 회전해야 한다.
     - 각각의 자식 모델은 방향과 중심점을 가져야 한다.
   - 제안(이지만 사실상 이 방법으로 갈 것 같다.) :
     - `centor`가 갖던 본래의 의미를 버리고, `(0,0,0)`을 중심점으로 갖도록 한다.
     - 모델의 좌표들은 기본적으로 움직이지 않는다. 렌더링 때 사용하는 좌표는 객체를 새로 생성해 사용한다.~~(<<실행 시간이 조금 걱정되는데 일단 적용시키고 보자)~~
     - `centor`와 `direction`을 선언해 **최상위 모델에 대한** 위치, 방향을 저장한다.
       - 상위 모델을 회전시킬 때 수정되는 것은 이 정보들 뿐이다.
       - 최상위 모델의 `centor`는 `(0,0,0)`로 고정된다.

3. `Object`가 움직일 때, 부속된 `Model`도 움직이게 만들기 | **출력 직전에 계산해서 만들기**
   - 후자의 경우 `Model`의 `Center`필드를 제거하는 것이 가능하다.

4. 오브젝트 회전의 중심점 확장
   - 부모 오브젝트의 회전과 자유로운 회전을 위해 회전 중심점을 가변적으로 설정할 수 있어야 한다.
   - 이때, 중심 이외의 회전점을 지정할 수 있도록 함수를 정의해야 한다.
